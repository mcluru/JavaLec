# 1. 형변환

자료형을 변환하는 기능</p>
묵시적(자동) 형변환 / 명시적(강제)로 나뉨</p>

- 묵시적 형변환1 : 바이트 크기가 작은 단위의 값을 큰 단위의 값으로 변경</p>
  ex) int a = 10;</p>
  long b = a; → a의 자료형이 자동으로 long으로 변경됨
- 묵시적 형변환2 : 더 세밀한 자료형으로 자동으로 형변환</p>
  ex) int a = 10;</p>
  float b = a; → 같은 4byte지만 실수의 표현범위가 더 세밀하기 때문에 a가 float로 자동 형변환
- long과 float의 형변환 : long이 8byte, float가 4byte지만, 실수의 표현범위가 더 세밀하고 넓기 때문에 long → float로 형변환된다</p>
  즉, 바이트의 크기가 아닌 표현범위/표현방식이 크고 세밀한 쪽으로 변경된다
- 형변환되는 순서</p>
  byte(1) → short(2) → int(4) → long(8) → float(4) → double(8)

---

- 명시적 형변환1 : 큰 단위의 자료형을 작은 단위의 자료형에 대입할 때, 대입할 값에 작은 단위의 자료형을 명시하여 형변환</p>
  ex) long lonVal - 100000L;</p>
  int intVal = (int)longVal;</p>
  int intVal2 = 20;</p>
  short shortVal = (short)intVal2;</p>
  Q.표현범위 상관없나?
- 명시적 형변환2 : 자료형의 값을 덜 세밀한 자료형에 대입할 때, 덜 세밀한 자료형을 명시하여 형변환</p>
  ex) float floatVal = 3.14f;
  int intVal = (int)floatVal;

---

- 연산에서의 형변환 : 바이트가 큰 자료형과 작은 자료형을 연산할 때, 작은 자료형이 큰 자료형으로 자동 변환
- 문자열 결합 연산자(+)의 형변환 : 문자열(String)과 다른 자료형을 + 연산하면 문자열 결합 연산으로 인식하여, 다른 자료형이 문자열로 형변환된 후 연산됨
  ex) "ab" + "cd" = "abcd"

# 2. 연산자 (operator)

- 단항연산자 / 이항연산자 / 삼항연산자</p>
  항(operand) : 피연산자
- 단항연산자 : 항이 1개인 연산자</p>
  ex) num++
- 이항연산자 : 항이 2개인 연산자</p>
  ex) 사칙연산
- 삼항연산자 : 항이 3개인 연산자</p>
  삼항 조건 연산자만 해당됨. ex) (a>10) ? "success" : "fail"

# 3. 단항연산자

증감연산자, 부호연산자가 대표적임.

- 부호연산자 : 부호를 변경함</p>
  ex) +num1, -num2 (-부호연산자는 부호가 반전된다)
- 증감연산자(증가 감소 연산자) : 전위연산자 / 후위연산자</p>
  ++(항에 1을 더해서 대입), --(항에 1을 빼서 대입) 등 연산자의 위치에 따라 전위,후위 판별.
  - 전위연산자 : 증감연산자라 항(피연산자) 앞에 위치</p>
    ex) ++num1(num1 = num1+1), --num2(num2 = num2-1)
  - 후위연산자 : 증감연산자가 항(피연산자) 뒤에 위치</p>
    ex) num1++, num2--</p>
  - 연산방식에는 차이 X, 연산 및 동작 순서에서 차이 발생</p>
    전위연산자 : 어떠한 동작/연산 발생 전 먼저 실행</p>
    후위연산자 : 어떠한 동작/연산 발생 후 실행</p>
    ex) int intVal1 = 10;</p>
    System.out.println(++intVall1); => 11 출력</p>
    ex) int intVal2 = 10;</p>
    System.out.println(++intVall1); => 10 출력 후 값 변경

# 4. 이항연산자

대입연산자(=), 산술연산자(+,-,_,/,%), 복합대입연산자(+=, -=, _=, /=, %=), 관계연산자(<, >, <=, >=, ==, !=), 논리연산자(&&, ||, !)

- 대입연산자 : 왼쪽 항의 변수에 오른쪽 항의 값을 대입</p>
  ex) int a;</p>
  int b = 10;</p>
  a = b; =>a에 b의 값인 10 대입
- 산술연산자 : 왼쪽 항의 값에서 오른쪽 항의 값을 산술연산</p>
  - %(나머지 연산자) : 왼쪽 항의 값에서 오른쪽 항의 값을 나눈 나머지 값을 반환</p>
    ex) int c = 11;</p>
    int d = 2;</p>
    int e = c%d; =>11을 2로 나눈 나머지(1)를 e에 대입
- 복합 대입연산자 : 왼쪽 항의 값에서 오른쪽 항의 값을 =앞의 산술연산자로 연산한 결과를 다시 왼쪽 항에 대입</p>
  ex) int f = 100;</p>
  int g = 10;</p>
  f += g; <- 같음 -> f = f+g;</p>
- 관계연산자 : 왼쪽 항의 값을 기준으로, 오른쪽 항의 값과 크기/동일여부를 연산</p>
  결과값은 true/false 로 반환.</p>
  ex) 10 > 100 => false</p>
  10 < 100 => true
- 논리연산자 : 논리곱(&&), 논리합(||), 부정(!)연산을 진행
  - 논리곱(&&) : 두 항이 모두 true여야 true 반환. (false가 1개라도 있으면 false)</p>
    ex) 10 < 20(t) && 30 < 40(t) => true</p>
    10 > 20(f) && 30 < 40(t) => false</p>
  - 논리합(||) : 두 항 중 한개라도 true면 true 반환. (모두 false일 때 false)</p>
    ex) 10 < 20(t) || 30 < 40(t) => true</p>
    10 > 20(f) || 30 < 40(t) => true</p>
    10 > 20(f) || 30 > 40(f) => false
  - 부정(!) : 부정연산자 오른쪽 항의 값을 반전. true -> false, false -> true</p>
    ex) !(10 < 20(t)) => false</p>
    ex) !(10 > 20(f)) => true</p>

# 5. 삼항연산자

삼항 조건 연산자만 존재.</p>
삼항 조건 연산자 : A ? B : C</p>
A : 조건/true/false</p>
B : A의 조건/값이 true일때 동작할 로직/선택될 값</p>
C : A의 조건/값이 false일때 동작할 로직/선택될 값</p>
ex) int a = 10;</p>
int b = 21;</p>
int c = (a < b) ? b : a; => a < b가 true면 b의 값을, false면 a의 값을 c에 대입.</p>
a < b가 true. b의 값인 21이 c에 대입됨.

- 삼항 조건 연산자의 중첩  
   A ? B : C ? D : E; => false일땐 C로 이동해서 다시 조건연산.  
   A ? <span style="color: blue;"> B ? C : D</span> : <span style="color: red;">E ? F : J</span>; => A가 true면 B에서 다시, false면 E에서 다시 조건연산  
   첫번째 조건에서 분기되는 ? 와 : 뒤에 다시 삼항 조건 연산자를 열어서, 삼항 조건 연산자를 중첩 사용할 수 있다.
  .
